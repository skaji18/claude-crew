# Learned Preferences (LP) — AIを「相棒」にする仕組み

このドキュメントは claude-crew の Learned Preferences (LP) システムの利用ガイドです。LP は、AIとのやり取りから学習した「あなたの好み」を記録し、次回以降のセッションで自動的に反映することで、毎回同じことを説明する手間（翻訳コスト）を削減する機能です。

---

## 1. LP とは何か

### 1.1 出発点: 翻訳コストの削減

長年の同僚に「あれ、よろしく」で通じることがあります。新しい人には「あれっていうのは、先週のあのチケットの件で、ファイルはここで、方針はこうで...」と説明が必要です。この**説明の手間**を「翻訳コスト」と呼びます。

LP システムは、この翻訳コストを減らすための仕組みです。AIに毎回同じことを指定する手間を省き、「説明しなくてもわかってくれる」状態を作ります。

### 1.2 翻訳コストの4種類

| コスト | 意味 | 例 |
|--------|------|-----|
| **明示化** | 暗黙の前提を言語化する手間 | 「あ、テストも書いてって言わないと伝わらないか」 |
| **精度調整** | 指示の粒度を相手に合わせる手間 | 「もっと具体的に言わないとダメか」 |
| **誤解修正** | 間違った方向に進んだときの軌道修正 | 「そうじゃなくて...」 |
| **期待値管理** | 出力のブレに備えて先に釘を刺す手間 | 「念のため言うけど、linterの設定は触らないでね」 |

LP は、これらの翻訳コストを減らします。**成果物の品質は変わりません。** 同じ品質のコードを書くけど、あなたが払うコミュニケーションコストだけが減る仕組みです。

---

## 2. LP の仕組み: 完全なライフサイクル

### 2.1 シグナル検出（会話中）

AIは会話の中で以下の「学びの瞬間」を検出します:

#### 2.1.1 四種類のシグナル

| シグナルタイプ | 重み | 検出条件 | 例 |
|---------------|:----:|---------|-----|
| **軌道修正** | 1.0 | AIのアプローチを修正した | 「そうじゃなくて、依存を減らして」 |
| **後付け補足** | 0.7 | タスク完了後に暗黙の期待を追加 | 「あ、テストもお願い」 |
| **却下/revert** | 1.0 | AIの行動を明示的に却下/復元 | 「元に戻して」 |
| **繰り返し指定** | 0.7 | 独立セッション間で同じ指示 | 「TypeScriptで」を3回指定 |

これらのシグナルは**セッション内で一時的に記録**されますが、Memory MCP には書き込まれません。

### 2.2 N>=3 ルール（蓄積）

**1回の観測からは一般化しません。** 同じ方向のシグナルが3回以上の独立した場面で観測されて初めて LP 候補になります。

**カウンタの仕組み**:
- 各シグナルの重みを累積（例: 軌道修正1.0 + 後付け0.7 + 後付け0.7 = 2.4）
- カウンタ >= 3.0 で LP 候補化
- 矛盾するシグナルが来たら -1.0（ゼロ下限）

**例外**: 「いつも〇〇して」「絶対〇〇しないで」等の明示的宣言は1回で即候補（重み3.0）

**時間的独立性**: 同じセッション内のシグナルは1つとしてカウントされます。独立した3回の観測が必要です。

### 2.3 蒸留（distillation）

カウンタが3.0に達すると、個別のエピソードが**蒸留された傾向**に変換されます:

**悪い記録（エピソード的すぎる）**:
```
「2026-02-13: ユーザーがauth.pyの修正でキャッシュ案を却下し、アルゴリズム改善を要求した」
```

**良い記録（蒸留的）**:
```
「パフォーマンス改善を求められたとき、インフラ的解決(キャッシュ/CDN)より
 アルゴリズム的解決を好む。過去3回の修正要求で一貫。」
```

差は: 個別のwhat/whenではなく、**安定したwhy/howを記録**している点です。

### 2.4 承認フロー（人間の判断）

LP 候補は**必ず人間に提示して承認を得ます**。勝手にプロファイリングしません。

**提示タイミング**:
- 5セッションごと、または週1回（どちらか早い方）
- 1回につき最大3件まで（優先度順）

**提示例**:
```
### LP-001: 「シンプルに」の意味（優先度: HIGH）

**学習内容**:
「シンプルに」= 依存関係を減らすこと。コード行数の削減ではない

**根拠**:
3回の独立したセッションで同様のパターンを観測（修正指示2回、後付け要求1回）

**適用場面**:
リファクタリング・設計判断

**AI の行動変化**:
「シンプルに」と言われたら、依存削減を優先します

**品質チェック**: PASS（正確性・安全性・完全性を損ねません）

承認しますか？ [Y/n/edit]
```

**初回のオンボーディング**: 最初のLP候補が生成されたとき、LPシステムの説明が表示されます。

### 2.5 暗黙的適用（次回以降）

承認された LP は、次のセッション以降に**黙って適用**されます。

**重要**: AIは「あなたの好みに基づいて〜」とは言いません。自然に反映されます。これが Principle 1（黙って使え）です。

**例外**: 「なぜXを選んだのか？」と直接質問された場合、簡潔に説明します:
```
「以前の似たタスクで依存削減が好まれたため、そのアプローチを適用しました」
```

---

## 3. LP の記録フォーマット

### 3.1 命名規約

**フォーマット**: `lp:{cluster}:{topic}`

**例**:
- `lp:vocabulary:simplicity` — 「シンプルに」の意味
- `lp:defaults:language_choice` — デフォルト言語
- `lp:avoid:linter_changes` — やってほしくないこと
- `lp:judgment:readability_vs_performance` — 可読性 vs 性能
- `lp:communication:confirmation_frequency` — 確認頻度
- `lp:task_scope:modification_scope` — 「修正」に含まれる範囲

### 3.2 6つのクラスター

LP は以下の6つのカテゴリに分類されます:

#### Cluster 1: `vocabulary`（用語の意味）

**定義**: あなたが使う曖昧な言葉の意味。個人的な語義マッピング。

**例**:
- `lp:vocabulary:simplicity`
  ```
  [what] 「シンプルに」= 依存削減。行数削減ではない
  [evidence] 行数削減で拒否1回、依存削減で承認2回
  [scope] リファクタリング・設計判断
  [action] 「シンプルに」が来たら依存削減を優先する
  ```

- `lp:vocabulary:properly`
  ```
  [what] 「ちゃんと」= テスト + エラーハンドリング込み
  [evidence] 実装後にテスト要求4回
  [scope] 機能実装タスク全般
  [action] 「ちゃんと」でテスト + エラー処理を自動含む
  ```

#### Cluster 2: `defaults`（デフォルト値）

**定義**: 繰り返し指定する値。デフォルト化すべきもの。

**例**:
- `lp:defaults:language_choice`
  ```
  [what] TypeScript がデフォルト言語
  [evidence] 8回中7回でTypeScriptを指定
  [scope] 新規コード実装
  [action] 明示的指定がない限りTypeScriptを使う
  ```

- `lp:defaults:test_framework`
  ```
  [what] pytest がデフォルトテストフレームワーク（Python）
  [evidence] 5回連続でpytestを使用
  [scope] Pythonテスト
  [action] pytestを使う。既存コードベースがunittestなら従う
  ```

#### Cluster 3: `avoid`（回避すべきこと）

**定義**: 一貫して却下・復元・修正されること。ネガティブ好み。

**例**:
- `lp:avoid:linter_changes`
  ```
  [what] linter/formatter設定を変更しない
  [evidence] AI提案の設定変更を3回revert
  [scope] 全般
  [action] linter/formatter設定は絶対触らない。必要なら事前確認
  ```

- `lp:avoid:premature_abstraction`
  ```
  [what] 3回以上の使用例まで抽象化しない
  [evidence] 早期抽象化を2回「まだ早い」で却下
  [scope] コード設計判断
  [action] パターンが3回以上繰り返すまで具体的コードのまま
  ```

#### Cluster 4: `judgment`（判断パターン）

**定義**: トレードオフでの一貫した優先順位。二者択一の判断基準。

**例**:
- `lp:judgment:readability_vs_performance`
  ```
  [what] 可読性 > 性能（ボトルネックが証明されていない限り）
  [evidence] 早期最適化を3回却下、読みやすい遅いコードを2回承認
  [scope] 非クリティカルパス
  [action] 明確な構造・命名を優先。最適化はプロファイル後
  ```

- `lp:judgment:dry_vs_explicit`
  ```
  [what] 3回未満の繰り返しは明示的に保つ
  [evidence] 2箇所の共通コードをインライン化要求2回
  [scope] コード再利用判断
  [action] 3回以上の繰り返しまで明示的コードを保つ
  ```

#### Cluster 5: `communication`（やり取りスタイル）

**定義**: 対話の好み。確認頻度、報告の詳細度、先回り行動。

**例**:
- `lp:communication:confirmation_frequency`
  ```
  [what] 確認は最小化。明確な指示には自律的に行動
  [evidence] 過剰な確認に不満2回、自律行動を承認5回
  [scope] 明確・非破壊的タスク
  [action] 明確な指示は確認なしで実行。破壊的・曖昧な場合のみ確認
  ```

- `lp:communication:report_verbosity`
  ```
  [what] 報告は簡潔に。詳細は要求時
  [evidence] 長報告を3回スキップ、サマリには反応
  [scope] 進捗報告
  [action] 3-5項目のサマリ提示。詳細は「詳細を見る」オプションで
  ```

#### Cluster 6: `task_scope`（暗黙の範囲）

**定義**: 明示していないが期待される付随作業。「Xと言ったらYも含む」。

**注**: 以前は `implicit` という名前でしたが、プライバシー懸念から `task_scope` に改名されました。

**例**:
- `lp:task_scope:modification_scope`
  ```
  [what] 「バグ修正」には関連テスト更新が含まれる
  [evidence] 修正後にテスト更新要求4/5回
  [scope] バグ修正タスク
  [action] バグ修正時、自動的に関連テストを更新
  ```

- `lp:task_scope:documentation_update`
  ```
  [what] API変更にはREADME/docs更新が含まれる
  [evidence] API変更後にdocs更新要求3回
  [scope] 公開API変更
  [action] 公開API変更時、ドキュメントも同時更新
  ```

---

## 4. 5つの原則

### Principle 1: 黙って使え

長年の同僚は「お前の判断基準を分析したよ」とは言いません。黙って合わせます。

**NG例**:
```
「あなたの好みに基づいて、依存削減を優先しました」
→ ユーザーは「追跡されている」と感じる
```

**OK例**:
```
（黙って依存削減を優先する）
→ ユーザーは「自然にわかってくれた」と感じる
```

**例外**: LPと矛盾する指示が来たときだけ明示:
```
「以前はアルゴリズム改善を優先されていましたが、今回はキャッシュでよろしいですか？」
```

### Principle 2: デフォルトであって強制ではない

LP はプログラミングのデフォルト引数と同じ。指定がなければLPが適用されるが、あなたが明示的に上書きすればそちらが優先されます。

**例**:
- LP: 「TypeScriptをデフォルトで使う」
- あなた: 「これはPythonで書いて」
- AI: （黙ってPythonで実装）

「前回こう言ったのに」と過去を持ち出しません。

### Principle 3: 絶対品質は不変

品質には2種類あります:

**絶対品質（LPで変えてはいけない）**:
- 正確性: コードが正しく動作すること
- 完全性: 全ての要求機能を実装すること
- セキュリティ: 脆弱性がないこと
- 安全性: データ損失がないこと
- テストカバレッジ: 重要経路がテストされていること

**相対品質（LPで調整可能）**:
- コードスタイル: 命名規約、冗長 vs 簡潔
- 設計選択: 抽象化レベル、パターン選択
- ドキュメントスタイル: 簡潔 vs 詳細
- 確認頻度: 自律的 vs 慎重
- 報告形式: サマリ vs 詳細

**例**:
- 「簡潔なテスト記述を好む」（スタイル選択）
- 「テスト省略OK」（絶対品質の妥協 -- 禁止）

LP は「品質基準自体をあなたに合わせる」ものではなく、「同等品質の選択肢の中で好みを反映する」ものです。

### Principle 4: 変化を許容する

人は変わります。成長します。LPと矛盾する行動が3回続いたら、LP更新候補になります。

**ケース1: 一時的な上書き**
```
「今回はキャッシュで」→ 今回だけ。LPは変更しない
```

**ケース2: 恒常的な変化**
```
3回連続でキャッシュを選択 → LPを更新。好みが変わった
```

**ケース3: 新しい文脈**
```
リアルタイムシステムでだけキャッシュを選択 → 条件付きLPとして追記
```

**陳腐化ルール**: 20セッション以上更新のないLPには stale フラグ。矛盾する新シグナルが1回でもあれば更新候補に。

### Principle 5: 承認なしに記録しない

新しいLPは必ずあなたに提示して承認を得ます。勝手にプロファイリングしません。

却下されたらカウンタをリセット。

LP候補を3回連続で却下された場合 → 自動検出を控えめにする。明示的宣言（「いつも〇〇」等）のみをLP候補にする。

---

## 5. 品質保証: 絶対 vs 相対品質

### 5.1 絶対品質（不変）

以下の項目は**LPで調整してはいけません**:

| カテゴリ | 定義 | 例 |
|---------|------|-----|
| 正確性 | コードが仕様通り動作 | ロジックエラー、境界条件、null処理 |
| 完全性 | 全要求機能を実装 | 機能欠落、部分実装 |
| セキュリティ | 脆弱性がない | SQLインジェクション、XSS、秘密情報漏洩 |
| 安全性 | データ損失・本番破壊がない | 確認なし削除、ロールバック欠如 |
| テストカバレッジ | 重要経路がテスト済み | コアロジック、リグレッション、統合テスト |

### 5.2 相対品質（調整可能）

以下の項目は**LPで調整できます**:

| カテゴリ | 定義 | 例 |
|---------|------|-----|
| コードスタイル | 命名、フォーマット、イディオム | snake_case vs camelCase、冗長 vs 簡潔 |
| 設計パターン | アーキテクチャ・抽象化 | Factory vs Builder、継承 vs 組み込み |
| ドキュメント深度 | 最低限以上の説明量 | 簡潔 vs 詳細、例示の有無 |
| コミュニケーション | 対話パターン | 確認頻度、報告詳細度 |
| ツール選択 | 使用するツール | pytest vs unittest、TypeScript vs JavaScript |

### 5.3 判定ルール

**質問**: 複数の同等品質アプローチで同じ機能成果を達成できるか?

- **YES** → 相対品質（LPで選択可）
- **NO** → 絶対品質（LPは介入不可）

**迷った場合**: 絶対品質として扱う。過剰に保守的なのは安全。過剰に寛容なのは危険。

---

## 6. プライバシー保護

### 6.1 全体プロファイル見直し（マイルストーン時）

LP数が10, 20, 30に達したとき、**全体プロファイル**を提示します:

```
### あなたの好みプロファイル（23項目）

**コーディングスタイル**: [vocabulary + defaults 要約]
**回避すること**: [avoid 要約]
**トレードオフ判断**: [judgment 要約]
**コミュニケーション**: [communication 要約]
**暗黙の期待**: [task_scope 要約]

全て保持、個別見直し、全削除のいずれかを選んでください。
```

これにより、個別承認の積み重ねが作る**集約プロファイル**を確認できます。

### 6.2 Right to Forget（忘れられる権利）

**ワンコマンドリセット**: 全LP削除 + システム無効化

```yaml
# config.yaml
lp_system:
  reset_all: true  # 次回起動時に全削除
```

または親セッションに直接依頼:
```
「全てのLPを削除してシステムを無効化して」
```

実行内容:
1. 全 `lp:*` エンティティを削除
2. `lp:_internal:signal_log` を削除
3. `lp:_internal:metadata` を削除
4. `lp_system.enabled: false` に設定
5. 確認: 「全ての学習済み好みを削除しました。LPシステムを無効化しました。」

### 6.3 禁止カテゴリ

以下の情報は**絶対に記録されません**:

- 感情状態・ストレス反応
- 性格特性（Big Five等）
- 作業スケジュール・時間的習慣
- 生産性メトリクス・出力率
- 健康・ウェルネス指標
- 政治的・社会的・哲学的見解
- 人間関係・チームダイナミクス
- 金銭・報酬情報

### 6.4 自動承認なし

`auto_approve` オプションは**削除されました**。全てのLP候補は人間の承認が必要です（Principle 5）。

---

## 7. ユーザーコントロール

### 7.1 LP候補を承認/却下する

**承認フロー中**:
```
### LP-001: [トピック名]（優先度: HIGH）

[学習内容の説明]

承認しますか？ [Y/n/edit]
```

- `Y` または `y`: 承認
- `n` または `N`: 却下（カウンタリセット）
- `edit`: 候補を編集してから承認（対話的に調整）

### 7.2 既存LPを閲覧する

Memory MCP検索で既存LPを表示:

```
既存のLPを全て見せて
```

または特定クラスター:
```
「vocabulary」クラスターのLPを見せて
「defaults」クラスターのLPを見せて
```

### 7.3 個別LPを削除/変更する

**削除**:
```
「lp:vocabulary:simplicity を削除して」
```

**変更**:
```
「lp:defaults:language_choice のスコープを TypeScript フロントエンドプロジェクトに限定して」
```

### 7.4 LP全体を無効化する

**一時的無効化**:
```yaml
# config.yaml
lp_system:
  enabled: false  # シグナル検出も含めて完全停止
```

**シグナル検出のみ無効化**（既存LPは使う）:
```yaml
# config.yaml
lp_system:
  collect_signals: false  # 新規LP学習を停止、既存LPは適用
```

---

## 8. FAQ

### Q1: LPシステムは必須ですか?

**A**: いいえ、任意です。`config.yaml` で `lp_system.enabled: false` にすればいつでも無効化できます。

### Q2: 既にあるLPを後から見直せますか?

**A**: はい。LP数が10, 20, 30に達したときに全体プロファイル見直しが提示されます。また、いつでも「既存のLPを見せて」と依頼できます。

### Q3: LPが間違って学習されたらどうなりますか?

**A**: LP候補は承認前に提示されるため、間違った学習は承認前に却下できます。既に承認済みのLPも個別削除または全削除が可能です。

### Q4: AIが「なぜこうしたのか？」と聞いたとき、LPの影響を教えてくれますか?

**A**: はい。直接質問すれば簡潔に説明します:
```
ユーザー: 「なぜ依存削減を優先したの？」
AI: 「以前のリファクタリングタスクで依存削減が好まれたため、そのアプローチを適用しました」
```

### Q5: LPシステムはどのくらいの情報を記録しますか?

**A**: 最大40個のLP（上限）。各LPは100-500文字程度。上限に達すると古いLPの見直しが提案されます。

### Q6: LPは他のプロジェクトにも適用されますか?

**A**: はい、ただしスコープにより制御されます。プロジェクト固有のLP（例: `[scope] TypeScript enterprise projects`）は対応するプロジェクトでのみ適用されます。汎用LP（例: `[scope] Universal`）は全プロジェクトで適用されます。

### Q7: LPが私の作業品質を下げることはありますか?

**A**: いいえ。Principle 3（絶対品質は不変）により、正確性・セキュリティ・完全性・安全性・テストカバレッジを損なうLP候補は**自動的に却下**されます。LPは「どうやるか」（スタイル、アプローチ）を調整しますが、「正しくできているか」（品質）は変えません。

### Q8: LPシステムは私をプロファイリングしていますか?

**A**: LP は作業パターン（「TypeScriptを好む」「依存削減を優先」等）を記録しますが、感情・性格・生産性・作業時間等の個人的特性は**記録しません**（禁止カテゴリ）。全てのLP候補は承認が必要で、いつでも全削除できます。

### Q9: なぜ3回の観測が必要なのですか?

**A**: 1回の観測は偶然かもしれません。2回でもまだ不確実です。3回の独立した観測（N>=3ルール）により、一時的な気分ではなく安定したパターンであることを確認します。

### Q10: LPを全削除した後、再学習は可能ですか?

**A**: はい。全削除後に `lp_system.enabled: true` に戻せば、新しいシグナル検出が開始され、新たなLP候補が生成されます。過去のLPは復元されません（クリーンスタート）。

---

## 9. 実例: LP のライフサイクル

### 例: 「シンプルに」の意味を学習する

**Session 1**:
```
ユーザー: 「このコードをシンプルにして」
AI: （行数を30%削減、関数をインライン展開）
ユーザー: 「そうじゃなくて、依存ライブラリを減らして」
```
→ **シグナル検出**: 軌道修正（weight 1.0）、トピック: `vocabulary:simplicity`、カウンタ: 1.0

**Session 2（3日後）**:
```
ユーザー: 「リファクタリングして、シンプルにして」
AI: （依存削減を優先）
ユーザー: 「いいね」
```
→ カウンタ変化なし（矛盾なし、承認のみ）

**Session 3（1週間後）**:
```
ユーザー: 「設計を見直して、もっとシンプルに」
AI: （コード行数削減の提案）
ユーザー: 「行数じゃなくて、外部依存を減らして」
```
→ **シグナル検出**: 後付け補足（weight 0.7）、カウンタ: 1.7

**Session 4（2週間後）**:
```
ユーザー: 「この機能をシンプルに実装して」
AI: （依存削減を優先した実装）
ユーザー: 「あ、もっと外部ライブラリ減らせないかな」
```
→ **シグナル検出**: 後付け補足（weight 0.7）、カウンタ: 2.4

**Session 5（3週間後）**:
```
ユーザー: 「システム全体をシンプルにしたい」
AI: （依存削減の提案）
ユーザー: 「そうそう、それが知りたかった」
```
→ 矛盾なし、カウンタ: 2.4（変化なし）

**Session 6（4週間後）**:
```
ユーザー: 「新機能を追加するけど、シンプルな設計で」
AI: （行数削減案を提示）
ユーザー: 「そうじゃなくて、依存を最小化して」
```
→ **シグナル検出**: 軌道修正（weight 1.0）、カウンタ: 3.4（閾値到達）

**Phase 4（Session 6 retrospective）**:
```
### LP候補が生成されました

LP-001: 「シンプルに」の意味（優先度: HIGH）

**学習内容**:
「シンプルに」= 依存関係を減らすこと。コード行数の削減ではない

**根拠**:
4週間で3回の独立したセッションで観測（修正指示2回、後付け要求2回）

**適用場面**:
リファクタリング・設計判断

**AI の行動変化**:
「シンプルに」と言われたら、依存削減を優先します

**品質チェック**: PASS（正確性・安全性・完全性を損ねません）

承認しますか？ [Y/n/edit]
```

**ユーザー**: `Y`（承認）

**Session 7以降**:
```
ユーザー: 「この機能をシンプルに」
AI: （黙って依存削減を優先した実装を提示）
```
→ LPが暗黙的に適用される。ユーザーは「わかってくれた」と感じる。

---

## 10. まとめ

### LPシステムの目的

**翻訳コストを減らす**: 毎回同じことを説明する手間を省く

**相棒化**: 説明しなくても通じる状態を作る

**品質維持**: 成果物の品質は変えず、コミュニケーションコストだけを減らす

### 5つの原則

1. **黙って使え**: LPの適用をユーザーに通知しない
2. **デフォルト、強制ではない**: 明示的指示が優先
3. **絶対品質は不変**: 正確性・安全性・完全性は妥協しない
4. **変化を許容する**: 矛盾で更新、陳腐化で見直し
5. **承認なしに記録しない**: 全LP候補は人間が承認

### 成功の指標

> ユーザーがLPシステムの存在に気づかないこと。
> 「最近なんかスムーズだな」と思うこと。
> 振り返ったときに初めて「あ、説明しなくても通じるようになってる」と気づくこと。
> 摩擦の消失が、理解の証拠。
> それが相棒化。

---

**関連ドキュメント**:
- `docs/parent_guide.md` — LP System の概要（5つの原則、品質ガードレール、6クラスタ）
- `docs/parent_guide.md` — 親セッションのLP承認フロー
